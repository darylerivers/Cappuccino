"""
CGE Stress Test Runner
Automates CGE stress testing for pipeline validation.
"""

import csv
import logging
import numpy as np
import subprocess
import sys
from pathlib import Path
from typing import Dict, Optional
import time


class CGEStressRunner:
    """Runs CGE stress tests programmatically for pipeline validation."""

    def __init__(self, num_scenarios: int = 200):
        self.logger = logging.getLogger(__name__)
        self.num_scenarios = num_scenarios
        self.results_dir = Path("stress_test_results")
        self.results_dir.mkdir(exist_ok=True)

    def run(self, trial_number: int, retries: int = 2) -> Optional[Dict]:
        """
        Run CGE stress test for a trial.

        Args:
            trial_number: Trial number to test
            retries: Number of retry attempts

        Returns:
            Dict with stress test metrics or None if failed
        """
        self.logger.info(f"Running CGE stress test for trial {trial_number} ({self.num_scenarios} scenarios)")

        # Check if model exists
        model_dir = self._find_model_dir(trial_number)
        if not model_dir:
            self.logger.error(f"Model directory not found for trial {trial_number}")
            return None

        # Run stress test with retries
        for attempt in range(retries):
            try:
                metrics = self._run_stress_test(trial_number, model_dir)
                if metrics:
                    self.logger.info(f"CGE stress test successful for trial {trial_number}")
                    return metrics

                self.logger.warning(f"CGE stress test attempt {attempt + 1}/{retries} failed")

                if attempt < retries - 1:
                    time.sleep(300)  # Wait 5 minutes before retry

            except Exception as e:
                self.logger.error(f"CGE stress test error (attempt {attempt + 1}): {e}", exc_info=True)

                if attempt < retries - 1:
                    time.sleep(300)

        return None

    def _find_model_dir(self, trial_number: int) -> Optional[Path]:
        """Find model directory for a trial."""
        possible_paths = [
            Path(f"train_results/cwd_tests/trial_{trial_number}_1h"),
            Path(f"train_results/cwd_tests/trial_{trial_number}"),
        ]

        for path in possible_paths:
            if path.exists() and (path / "actor.pth").exists():
                return path

        return None

    def _generate_stress_test_script(self, trial_number: int, model_dir: Path) -> Path:
        """Generate stress test script based on template."""
        script_path = Path(f"stress_test_trial{trial_number}_auto.py")

        script_content = f'''#!/usr/bin/env python3
"""
Auto-generated CGE Stress Test for Trial {trial_number}
Generated by pipeline orchestrator
"""

import numpy as np
import pandas as pd
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from stress_test_cge import run_cge_stress_test

if __name__ == "__main__":
    model_dir = "{model_dir}"
    trial_number = {trial_number}
    num_scenarios = {self.num_scenarios}

    print(f"Running CGE stress test for trial {{trial_number}}")
    print(f"Model directory: {{model_dir}}")
    print(f"Number of scenarios: {{num_scenarios}}")

    # Run stress test
    results = run_cge_stress_test(
        model_dir=model_dir,
        trial_number=trial_number,
        num_scenarios=num_scenarios,
        output_file="stress_test_results/trial_{trial_number}_cge.csv"
    )

    # Print summary
    if results is not None:
        print(f"\\nStress test completed successfully")
        print(f"Results saved to stress_test_results/trial_{trial_number}_cge.csv")
    else:
        print(f"\\nStress test failed")
        sys.exit(1)
'''

        with open(script_path, 'w') as f:
            f.write(script_content)

        script_path.chmod(0o755)
        self.logger.info(f"Generated stress test script: {script_path}")

        return script_path

    def _run_stress_test(self, trial_number: int, model_dir: Path) -> Optional[Dict]:
        """
        Run stress test by generating and executing script.
        """
        # Check if we already have recent results
        results_file = self.results_dir / f"trial_{trial_number}_cge.csv"
        if results_file.exists():
            self.logger.info(f"Found existing stress test results: {results_file}")
            metrics = self._parse_results(results_file)
            if metrics:
                return metrics

        # Generate stress test script
        script_path = self._generate_stress_test_script(trial_number, model_dir)

        try:
            # Run stress test script
            cmd = [sys.executable, str(script_path)]

            self.logger.info(f"Executing stress test: {' '.join(cmd)}")

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3600,  # 1 hour timeout (stress tests are slow)
                cwd=Path.cwd()
            )

            if result.returncode != 0:
                self.logger.error(f"Stress test failed with code {result.returncode}")
                self.logger.error(f"stderr: {result.stderr}")
                return None

            # Parse results
            if results_file.exists():
                metrics = self._parse_results(results_file)
                return metrics
            else:
                self.logger.error(f"Results file not created: {results_file}")
                return None

        except subprocess.TimeoutExpired:
            self.logger.error("Stress test timed out after 1 hour")
            return None
        except Exception as e:
            self.logger.error(f"Stress test execution error: {e}", exc_info=True)
            return None
        finally:
            # Clean up generated script
            if script_path.exists():
                script_path.unlink()

    def _parse_results(self, results_file: Path) -> Optional[Dict]:
        """Parse CGE stress test results CSV."""
        try:
            # Read CSV
            df = pd.read_csv(results_file)

            if df.empty:
                self.logger.error("Results file is empty")
                return None

            # Calculate metrics
            total_scenarios = len(df)

            # Profitable scenarios (total return > 0)
            profitable = (df['total_return'] > 0).sum()
            profitable_pct = profitable / total_scenarios

            # Median Sharpe
            median_sharpe = df['sharpe_ratio'].median()

            # Max drawdown across all scenarios
            max_drawdown = df['max_drawdown'].max()

            # Catastrophic failures (loss > 90%)
            catastrophic_threshold = -0.90
            catastrophic_failures = (df['total_return'] < catastrophic_threshold).sum()

            # Additional stats
            mean_return = df['total_return'].mean()
            worst_return = df['total_return'].min()
            best_return = df['total_return'].max()

            metrics = {
                "total_scenarios": total_scenarios,
                "profitable_pct": profitable_pct,
                "median_sharpe": median_sharpe,
                "max_drawdown": max_drawdown,
                "catastrophic_failures": int(catastrophic_failures),
                "mean_return": mean_return,
                "worst_return": worst_return,
                "best_return": best_return,
            }

            self.logger.info(f"Parsed CGE metrics: {metrics}")
            return metrics

        except Exception as e:
            self.logger.error(f"Error parsing results: {e}", exc_info=True)
            return None


# Import pandas here to avoid import errors if not installed
try:
    import pandas as pd
except ImportError:
    pd = None
    logging.getLogger(__name__).warning("pandas not available, CGE runner will fail")
